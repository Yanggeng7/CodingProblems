#include <iostream> 
#include <set>
#include <unordered_map>


/*-------------------------------------------------------------------------*/
// Fibonacci problem                                                        /
/*-------------------------------------------------------------------------*/
int fib(int n){
  // Time Complexity: O(2^n)
  // Space Complexity: O(n)

  if(n == 1 || n == 2)
    return n;
  else
    return (fib(n-1) + fib(n-2));
}

int fibWithMemo(int n, std::unordered_map<int, int>& memo){
  // int may have a memory leak issue

  // Time Complexity: O(n)
  // Space Complexity: O(n)

  memo[0] = 1;
  memo[1] = 1;
  if(memo.find(n) != memo.end())
    return memo[n];
  else{
    memo[n] = fibWithMemo(n-1, memo) + fibWithMemo(n-2, memo);
    return memo[n];
  }
}


/*-------------------------------------------------------------------------*/
// Grid traverler problem                                                   /
// Given m*n grid and traverler can only go right or down.                  /
// How many solutions to reach right-down from top-left.                    /
/*-------------------------------------------------------------------------*/
int gridTraveler(int m, int n){
  // Time Complexity: O(2^(m+n))
  // Space Complexity: O(m+n)
  if(m == 1 && n == 1) 
    return 1;
  if(m == 0 || n == 0)
    return 0;
  return gridTraveler(m-1, n) + gridTraveler(m, n-1);
}

int gridTravelerWithMemo(int m, int n, std::unordered_map<std::pair<int, int>,int>& memo){
  // std::pair cannot be directly used as map key
  // Need to define a hash function
  // Time Complexity: O(m*n)
  // Space Complexity: O(m+n)

  if(m == 1 && n == 1) 
    return 1;
  if(m == 0 || n == 0)
    return 0;
  std::pair<int, int> memoKey = {m, n};
  if(memo.find(memoKey) != memo.end())
    return memo[memoKey];
  else{
    memo[memoKey] = gridTravelerWithMemo(m-1, n, memo) + gridTravelerWithMemo(m, n-1, memo);
    return memo[memoKey];
  }
}


/*-------------------------------------------------------------------------*/
// canSum problem                                                           /
// Test whether a targetSum can be generated by the numbers in an array     /                                                             /
// elements inside the array can be used as many times as needed            /
/*-------------------------------------------------------------------------*/
bool canSum(int target, std::vector<int>& numList){
  // Time Complexity: O(numList.size()^target)
  // Space Complexity: O(m)
  if(target == 0)
    return true;
  if(target < 0)
    return false;
  
  for(auto i : numList){
    if(canSum(target-i, numList) == true)
      return true;
  }
  return false;
}

bool canSumWithMemo(int target, std::vector<int>& numList, std::unordered_map<int, bool>& memo){
  // Time Complexity:
  // Space Complexity:
  if(target < 0)
    return false;
  if(target == 0)
    return true;
  if(memo.find(target) != memo.end())
    return memo[target];

  for(auto i : numList){
    if(canSumWithMemo(target-i, numList, memo) == true){
      memo[target] = true;
      return true;
    }
  }
  return false;
}



